{% extends "base.html" %}

{% block content %}
<body>

<div class="d-flex align-items-center justify-content-between mb-4">
  <h4 class="mb-0 text-capitalize">
    Vue globale Cat√©gorie : {{ category }}
  </h4>
  <a class="btn btn-primary" href="{{ url_for('admin') }}">Retour</a>
</div>

<div class="mb-3 text-end">
  <label for="time-range" class="form-label small text-muted">P√©riode :</label>
  <select id="time-range" class="form-select d-inline w-auto">
    <option value="10m">10 min</option>
    <option value="1h">1 heure</option>
    <option value="24h">24 heures</option>
    <option value="7d">7 jours</option>
  </select>
</div>

{% if hosts %}
  {% for entry in hosts %}
    {% set host = entry.host %}
    <div class="card shadow-sm mb-4">
      <div class="card-body">
        <div class="d-flex align-items-center justify-content-between mb-3">
          <h5 class="mb-0">{{ host.hostname }}</h5>
          <a href="{{ url_for('host_view', host_id=host.id) }}" class="btn btn-sm btn-outline-primary">
            Voir le d√©tail
          </a>
        </div>

        <dl class="row small mb-3">
          <dt class="col-sm-3">IP / Port</dt>
          <dd class="col-sm-9">{{ host.ip }}:{{ host.port }}</dd>
          <dt class="col-sm-3">Communaut√© SNMP</dt>
          <dd class="col-sm-9">{{ host.snmp_community }}</dd>
        </dl>

        {% if entry.error %}
          <div class="alert alert-warning">{{ entry.error }}</div>
        {% else %}
          {% set metrics = entry.metrics %}
          {% if metrics %}

            {% if category == "interfaces" %}
              <!-- Vue interfaces : uniquement le graphe (comme host_detail) -->
              <canvas id="chart-traffic-{{ host.id }}" height="100"></canvas>

            {% else %}

              {% if category == "cpu" %}
                <table class="table table-sm">
                  <thead><tr><th>Core</th><th>Charge</th></tr></thead>
                  <tbody>
                    {% for cpu_oid, load in metrics.items() %}
                      <tr>
                        <td>Core {{ loop.index }}</td>
                        <td>
                          {% set pct = load|float %}
                          {# Lire les seuils sp√©cifiques √† l'h√¥te si pr√©sents, sinon valeurs par d√©faut #}
                          {% set cpu_conf = (host.thresholds or {}).get('cpu', {}) %}
                          {% set warn = (cpu_conf.get('warning', 80))|float %}
                          {% set crit = (cpu_conf.get('critical', 90))|float %}
                          {% if pct > crit %}
                            <span class="badge bg-danger">{{ pct }}%</span>
                          {% elif pct > warn %}
                            <span class="badge bg-warning text-dark">{{ pct }}%</span>
                          {% else %}
                            <span class="badge bg-success">{{ pct }}%</span>
                          {% endif %}
                        </td>
                      </tr>
                    {% endfor %}
                  </tbody>
                </table>
              {% endif %}

              {% if category == "ram" %}
                <table class="table table-sm">
                  <thead><tr><th>Type</th><th>Utilis√©</th><th>Total</th><th>%</th></tr></thead>
                  <tbody>
                    {% for name, info in metrics.items() %}
                      {% if info is mapping %}
                        <tr>
                          <td>{{ name }}</td>
                          <td>
                            {% if info.used >= 1073741824 %}
                              {{ "%.1f"|format(info.used / 1073741824) }} Go
                            {% elif info.used >= 1048576 %}
                              {{ "%.1f"|format(info.used / 1048576) }} Mo
                            {% else %}
                              {{ "%.1f"|format(info.used / 1024) }} Ko
                            {% endif %}
                          </td>
                          <td>
                            {% if info.total >= 1073741824 %}
                              {{ "%.1f"|format(info.total / 1073741824) }} Go
                            {% elif info.total >= 1048576 %}
                              {{ "%.1f"|format(info.total / 1048576) }} Mo
                            {% else %}
                              {{ "%.1f"|format(info.total / 1024) }} Ko
                            {% endif %}
                          </td>
                          <td>
                            {% set pct = info.pct|float %}
                            {# seuils host-specific si pr√©sents #}
                            {% set ram_conf = (host.thresholds or {}).get('ram', {}) %}
                            {% set warn = (ram_conf.get('warning', 80))|float %}
                            {% set crit = (ram_conf.get('critical', 90))|float %}
                            {% if pct > crit %}
                              <span class="badge bg-danger">{{ pct }}%</span>
                            {% elif pct > warn %}
                              <span class="badge bg-warning text-dark">{{ pct }}%</span>
                            {% else %}
                              <span class="badge bg-success">{{ pct }}%</span>
                            {% endif %}
                          </td>
                        </tr>
                      {% endif %}
                    {% endfor %}
                  </tbody>
                </table>
              {% endif %}

              {% if category == "storage" %}
                <table class="table table-sm">
                  <thead><tr><th>Volume</th><th>Utilis√©</th><th>Total</th><th>%</th></tr></thead>
                  <tbody>
                    {% for name, info in metrics.items() %}
                      {% if info is mapping %}
                        <tr>
                          <td>{{ name }}</td>
                          <td>
                            {% if info.used >= 1073741824 %}
                              {{ "%.1f"|format(info.used / 1073741824) }} Go
                            {% elif info.used >= 1048576 %}
                              {{ "%.1f"|format(info.used / 1048576) }} Mo
                            {% else %}
                              {{ "%.1f"|format(info.used / 1024) }} Ko
                            {% endif %}
                          </td>
                          <td>
                            {% if info.total >= 1073741824 %}
                              {{ "%.1f"|format(info.total / 1073741824) }} Go
                            {% elif info.total >= 1048576 %}
                              {{ "%.1f"|format(info.total / 1048576) }} Mo
                            {% else %}
                              {{ "%.1f"|format(info.total / 1024) }} Ko
                            {% endif %}
                          </td>
                          <td>
                            {% set pct = info.pct|float %}
                            {# seuils host-specific si pr√©sents (storage souvent plus stricts) #}
                            {% set storage_conf = (host.thresholds or {}).get('storage', {}) %}
                            {% set warn = (storage_conf.get('warning', 85))|float %}
                            {% set crit = (storage_conf.get('critical', 95))|float %}
                            {% if pct > crit %}
                              <span class="badge bg-danger">{{ pct }}%</span>
                            {% elif pct > warn %}
                              <span class="badge bg-warning text-dark">{{ pct }}%</span>
                            {% else %}
                              <span class="badge bg-success">{{ pct }}%</span>
                            {% endif %}
                          </td>
                        </tr>
                      {% endif %}
                    {% endfor %}
                  </tbody>
                </table>
              {% endif %}

              <!-- Graphe standard pour cpu/ram/storage -->
              <canvas id="chart-{{ category }}-{{ host.id }}" height="100"></canvas>

            {% endif %}
          {% endif %}
        {% endif %}
      </div>
    </div>
  {% endfor %}
{% else %}
  <div class="alert alert-warning">
    Aucun h√¥te ne surveille la cat√©gorie {{ category }}.
  </div>
{% endif %}

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

<script>
document.addEventListener('DOMContentLoaded', function () {
  const category = "{{ category }}";
  const charts = {};
  const timeSelect = document.getElementById('time-range');

  // Persist selected time-range per category so auto-refresh keeps user's choice
  try {
    const timeKey = `category_time_range_{{ category }}`;
    if (timeSelect) {
      const stored = localStorage.getItem(timeKey);
      if (stored) timeSelect.value = stored;
      timeSelect.addEventListener('change', () => {
        try { localStorage.setItem(timeKey, timeSelect.value); } catch (e) {}
      });
    }
  } catch (e) { /* ignore */ }

  function getMinutes() {
    const val = timeSelect ? timeSelect.value : '10m';
    if (val.endsWith('m')) return parseInt(val);
    if (val.endsWith('h')) return parseInt(val) * 60;
    if (val.endsWith('d')) return parseInt(val) * 24 * 60;
    return 10;
  }

  // üîπ Retourne l'unit√© de temps Chart.js et les displayFormats en fonction du nombre de minutes
  function timeUnitForMinutes(minutes) {
    if (minutes >= 24 * 60) {
      return { unit: 'day', displayFormats: { day: 'MMM d' } };
    }
    if (minutes >= 60) {
      return { unit: 'hour', displayFormats: { hour: 'HH:mm' } };
    }
    return { unit: 'minute', displayFormats: { minute: 'HH:mm' } };
  }

  // üîπ D√©tecte les gros 'gaps' temporels et ins√®re des points null pour couper la courbe.
  // Retourne la liste d'intervalles [{start: ISO, end: ISO}] repr√©sentant les p√©riodes manquantes.
  function detectAndInsertGaps(datasets) {
    const allTs = [];
    datasets.forEach(ds => ds.data.forEach(p => {
      try { allTs.push(new Date(p.x).getTime()); } catch (e) {}
    }));
    allTs.sort((a,b) => a - b);
    if (allTs.length < 2) return [];

    const deltas = [];
    for (let i = 1; i < allTs.length; i++) deltas.push(allTs[i] - allTs[i-1]);
    deltas.sort((a,b)=>a-b);
    const medianDelta = deltas[Math.floor(deltas.length/2)] || deltas[0] || 60000;
    const threshold = Math.max(medianDelta * 3, 2 * 60 * 1000); // au moins 2 minutes

    const intervals = [];
    for (let i = 1; i < allTs.length; i++) {
      const gap = allTs[i] - allTs[i-1];
      if (gap > threshold) {
        const start = new Date(allTs[i-1]).toISOString();
        const end = new Date(allTs[i]).toISOString();
        intervals.push({ start, end });

        // insert a null point at midpoint to force Chart.js to break the line
        const midMs = Math.floor((allTs[i-1] + allTs[i]) / 2);
        const midISO = new Date(midMs).toISOString();
        datasets.forEach(ds => {
          ds.data.push({ x: midISO, y: null });
          ds.data.sort((a,b) => new Date(a.x) - new Date(b.x));
        });
      }
    }
    return intervals;
  }

  // üîπ Plugin Chart.js pour dessiner une zone rouge lors des p√©riodes down d√©tect√©es
  const downZonePlugin = {
    id: 'downZone',
    beforeDraw(chart) {
      const cfg = chart.options.plugins && chart.options.plugins.downZone;
      if (!cfg || !cfg.intervals || !cfg.intervals.length) return;
      const xScale = chart.scales.x;
      if (!xScale) return;
      const ctx = chart.ctx;
      const top = chart.chartArea.top;
      const bottom = chart.chartArea.bottom;
      ctx.save();
      ctx.fillStyle = 'rgba(220,53,69,0.12)';
      cfg.intervals.forEach(iv => {
        try {
          const x1 = xScale.getPixelForValue(iv.start);
          const x2 = xScale.getPixelForValue(iv.end);
          const left = Math.min(x1, x2);
          const w = Math.abs(x2 - x1);
          ctx.fillRect(left, top, w, bottom - top);
        } catch (e) {}
      });
      ctx.restore();
    }
  };
  try { if (typeof Chart !== 'undefined') Chart.register(downZonePlugin); } catch (e) { console.warn('downZone plugin registration failed', e); }

  // ---- Interfaces (traffic) ----
  function loadInterfacesCanvas(canvas) {
    const hostId = canvas.id.split('-').pop();
    const minutes = getMinutes();

    fetch(`/api/poll/metrics/${hostId}/interfaces?minutes=${minutes}`)
      .then(r => r.json())
      .then(data => {
  if (!data || data.length === 0) return;

        const totalIn = {}, totalOut = {};
        data.forEach(entry => {
          const ts = entry.timestamp;
          if (entry.metric.endsWith('.in')) totalIn[ts] = (totalIn[ts] || 0) + entry.value;
          if (entry.metric.endsWith('.out')) totalOut[ts] = (totalOut[ts] || 0) + entry.value;
        });

        function computeRates(map) {
          const entries = Object.entries(map).sort((a, b) => new Date(a[0]) - new Date(b[0]));
          const rates = [];
          for (let i = 1; i < entries.length; i++) {
            const tPrev = new Date(entries[i - 1][0]);
            const tCurr = new Date(entries[i][0]);
            const dt = (tCurr - tPrev) / 1000;
            if (dt <= 0) continue;
            let delta = entries[i][1] - entries[i - 1][1];
            if (delta < 0) delta = 0;
            const mbps = (delta * 8) / (dt * 1_000_000);
            rates.push({ x: entries[i][0], y: mbps });
          }
          return rates;
        }

        const inData = computeRates(totalIn);
        const outData = computeRates(totalOut).map(p => ({ x: p.x, y: -p.y }));
        const datasets = [
          {
            label: 'Inbound (Mbps)',
            data: inData,
            borderColor: 'rgba(0, 200, 83, 0.9)',
            backgroundColor: 'rgba(0, 200, 83, 0.1)',
            fill: true,
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 4
          },
          {
            label: 'Outbound (Mbps)',
            data: outData,
            borderColor: 'rgba(244, 67, 54, 0.9)',
            backgroundColor: 'rgba(244, 67, 54, 0.1)',
            fill: true,
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 0,
            pointHoverRadius: 4
          }
        ];

        // detect gaps and insert nulls; get intervals for shading
        const gapIntervals = detectAndInsertGaps(datasets);

        const endTs = new Date();
        const startTs = new Date(endTs.getTime() - minutes * 60 * 1000);
        const tu = timeUnitForMinutes(minutes);

        const id = canvas.id;
        if (charts[id]) {
          charts[id].data.datasets = datasets;
          charts[id].options.plugins.title.text = `Overall Network Traffic (Mbps, ${minutes} min)`;
          charts[id].options.plugins.downZone = { intervals: gapIntervals };
          if (!charts[id].options.scales) charts[id].options.scales = {};
          if (!charts[id].options.scales.x) charts[id].options.scales.x = {};
          charts[id].options.scales.x.min = startTs.toISOString();
          charts[id].options.scales.x.max = endTs.toISOString();
          charts[id].options.scales.x.time = { unit: tu.unit, displayFormats: tu.displayFormats };
          charts[id].update();
          return;
        }

        charts[id] = new Chart(canvas.getContext('2d'), {
          type: 'line',
          data: { datasets },
          options: {
            responsive: true,
            interaction: { mode: 'index', intersect: false },
            stacked: false,
            plugins: {
              legend: { position: 'top' },
              title: { display: true, text: `Overall Network Traffic (Mbps, ${minutes} min)` },
              tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${Math.abs(ctx.parsed.y).toFixed(3)} Mbps` } }
            },
            plugins: { downZone: { intervals: gapIntervals } },
            scales: {
              x: { type: 'time', time: { unit: tu.unit, displayFormats: tu.displayFormats }, title: { display: true, text: 'Horodatage' }, min: startTs.toISOString(), max: endTs.toISOString() },
              y: { beginAtZero: true, title: { display: true, text: 'D√©bit (Mbps)' }, ticks: { callback: (v) => Math.abs(v) } }
            }
          }
        });
      })
      .catch(e => console.error('Erreur network traffic:', e));
  }

  // ---- Metric charts (cpu/ram/storage) ----
  function buildByMetric(data) {
    const byMetric = {};
    const metricMap = {};
    let coreIndex = 1;
    data.forEach(entry => {
      let label = entry.metric;
      if (category === 'cpu') {
        if (!metricMap[label]) metricMap[label] = `Core ${coreIndex++}`;
        label = metricMap[label];
      }
      if (!byMetric[label]) byMetric[label] = [];
      byMetric[label].push({ x: entry.timestamp, y: entry.value });
    });

    if (category === 'ram') {
      const filtered = {};
      if (byMetric['pct']) filtered['Physical memory'] = byMetric['pct'];
      Object.keys(byMetric).forEach(k => delete byMetric[k]);
      Object.assign(byMetric, filtered);
    }

    if (category === 'storage') {
      const filtered = {};
      data.forEach(entry => {
        let label = entry.metric;
        if (!label.endsWith('.pct')) return;
        const lname = label.toLowerCase();
        const ignored = ['shm','tmp','run','dev','proc','sys'];
        if (ignored.some(sub => lname.includes(sub))) return;
        label = label.replace(/\.pct$/, '');
        if (!filtered[label]) filtered[label] = [];
        filtered[label].push({ x: entry.timestamp, y: entry.value });
      });
      Object.keys(byMetric).forEach(k => delete byMetric[k]);
      Object.assign(byMetric, filtered);
    }

    return byMetric;
  }

  function loadMetricCanvas(canvas) {
    const hostId = canvas.id.split('-').pop();
    const minutes = getMinutes();
    fetch(`/api/poll/metrics/${hostId}/${category}?minutes=${minutes}`)
      .then(r => r.json())
      .then(data => {
          if (!data || data.length === 0) return;
          const byMetric = buildByMetric(data);
          const datasets = Object.entries(byMetric).map(([metric, points]) => ({
            label: metric,
            data: points.map(p => ({ x: p.x, y: p.y })),
            fill: false,
            tension: 0.2,
            pointRadius: 0,
            pointHoverRadius: 4
          }));

          // detect gaps and insert nulls; get intervals for shading
          const gapIntervals = detectAndInsertGaps(datasets);
          const endTs = new Date();
          const startTs = new Date(endTs.getTime() - minutes * 60 * 1000);
          const tu = timeUnitForMinutes(minutes);

          const id = canvas.id;
          const minutesText = `${minutes} min`;
          if (charts[id]) {
            charts[id].data.datasets = datasets;
            charts[id].options.plugins.title.text = `${category.toUpperCase()} - ${canvas.id.split('-').slice(1, -1).join('-')} (${minutesText})`;
            charts[id].options.plugins.downZone = { intervals: gapIntervals };
            if (!charts[id].options.scales) charts[id].options.scales = {};
            if (!charts[id].options.scales.x) charts[id].options.scales.x = {};
            charts[id].options.scales.x.min = startTs.toISOString();
            charts[id].options.scales.x.max = endTs.toISOString();
            charts[id].options.scales.x.time = { unit: tu.unit, displayFormats: tu.displayFormats };
            charts[id].update();
            return;
          }

          charts[id] = new Chart(canvas.getContext('2d'), {
            type: 'line',
            data: { datasets },
            options: {
              responsive: true,
              plugins: {
                title: { display: true, text: `${category.toUpperCase()} - ${canvas.id.split('-').slice(1, -1).join('-')} (${minutesText})` },
                tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}%` } },
                downZone: { intervals: gapIntervals }
              },
              scales: { x: { type: 'time', time: { unit: tu.unit, displayFormats: tu.displayFormats }, title: { display: true, text: 'Temps' }, min: startTs.toISOString(), max: endTs.toISOString() }, y: { beginAtZero: true, max: 100, title: { display: true, text: 'Utilisation (%)' } } }
            }
          });
      })
      .catch(e => console.error(`Erreur ${category} (${canvas.id}) :`, e));
  }

  function loadCharts() {
    // interfaces canvases
    document.querySelectorAll("canvas[id^='chart-traffic-']").forEach(c => loadInterfacesCanvas(c));
    // other metric canvases
    document.querySelectorAll(`canvas[id^='chart-${category}-']`).forEach(c => loadMetricCanvas(c));
  }

  if (timeSelect) timeSelect.addEventListener('change', () => loadCharts());

  // initial load
  loadCharts();
  // refresh every 20s
  setInterval(loadCharts, 20000);
});
</script>

</body>
{% endblock %}
