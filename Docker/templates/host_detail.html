{% extends "base.html" %}

{% if error %}
<div class="alert alert-warning">
  {{ error }}
</div>
{% endif %}

{% block content %}
<body data-host-id="{{ host.id }}">

<div class="d-flex align-items-center justify-content-between mb-4">
  <h4 class="mb-0">D√©tails du host : {{ host.hostname }}</h4>
  <div>
    {% if session.get('role') == 'admin' %}
      <!-- Bouton SSH (admin uniquement) -->
      <a class="btn btn-dark me-2"
         href="https://{{ host.ip }}:4200"
         target="_blank"
         title="Ouvrir un terminal SSH">
        <i class="fas fa-terminal"></i> Shell
      </a>

      <a class="btn btn-outline-secondary me-2"
         href="{{ url_for('host_edit', host_id=host.id) }}">
        Modifier
      </a>
    {% endif %}
    <a class="btn btn-primary" href="{{ url_for('admin') }}">Retour</a>
  </div>
</div>

<!-- Infos principales -->
<div class="card shadow-sm mb-4">
  <div class="card-body">
    <dl class="row mb-0">
      <dt class="col-sm-3">IP / Port</dt>
      <dd class="col-sm-9">{{ host.ip }}:{{ host.port }}</dd>

      <dt class="col-sm-3">Communaut√© SNMP</dt>
      <dd class="col-sm-9">{{ host.snmp_community }}</dd>

      <dt class="col-sm-3">Description</dt>
      <dd class="col-sm-9">{{ host.description or "‚Äî" }}</dd>

      <dt class="col-sm-3">Cat√©gories</dt>
      <dd class="col-sm-9">
        {% if host.snmp_categories %}
          {% for c in host.snmp_categories %}
            <span class="badge bg-info text-dark me-1">{{ c }}</span>
          {% endfor %}
        {% else %}‚Äî{% endif %}
      </dd>
    </dl>
  </div>
</div>
<div class="mb-3 text-end">
  <label for="time-range" class="form-label small text-muted">P√©riode :</label>
  <select id="time-range" class="form-select d-inline w-auto">
    <option value="10m">10 min</option>
    <option value="1h">1 heure</option>
    <option value="24h">24 heures</option>
    <option value="7d">7 jours</option>
  </select>
</div>
<!-- M√©triques SNMP -->
{% if metrics %}
  {% for category, values in metrics.items() %}
    <div class="card shadow-sm mb-4">
      <div class="card-body">
        <h5 class="card-title text-capitalize">{{ category }}</h5>

        {% if category == "system" %}
          <table class="table table-sm">
            <thead><tr><th>Champ</th><th>Valeur</th></tr></thead>
            <tbody>
              {% for label, val in system_data %}
                <tr><td>{{ label }}</td><td>{{ val }}</td></tr>
              {% endfor %}
            </tbody>
          </table>
        {% endif %}

        {% if category == "cpu" %}
          <table class="table table-sm">
            <thead><tr><th>Cores</th><th>Charge</th></tr></thead>
            <tbody>
              {% set warn = thresholds['cpu']['warning'] %}
              {% set crit = thresholds['cpu']['critical'] %}
              {% for cpu_oid, load in values.items() %}
                {% set pct = load|float %}
                <tr>
                  <td>Core {{ loop.index }}</td>
                  <td>
                    {% if pct > crit %}
                      <span class="badge bg-danger text-white">{{ pct }}%</span>
                    {% elif pct > warn %}
                      <span class="badge bg-warning text-dark">{{ pct }}%</span>
                    {% else %}
                      <span class="badge bg-success text-white">{{ pct }}%</span>
                    {% endif %}
                  </td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        {% endif %}


        {% if category == "ram" %}
          <table class="table table-sm">
            <thead><tr><th>Type</th><th>Utilis√©</th><th>Total</th><th>%</th></tr></thead>
            <tbody>
              {% set warn = thresholds['ram']['warning'] %}
              {% set crit = thresholds['ram']['critical'] %}
              {% for name, info in values.items() %}
                <tr>
                  <td>Physical memory</td>
                  <td>
                    {% if info.used >= 1073741824 %}
                      {{ "%.1f"|format(info.used / 1073741824) }} Go
                    {% elif info.used >= 1048576 %}
                      {{ "%.1f"|format(info.used / 1048576) }} Mo
                    {% else %}
                      {{ "%.1f"|format(info.used / 1024) }} Ko
                    {% endif %}
                  </td>
                  <td>
                    {% if info.total >= 1073741824 %}
                      {{ "%.1f"|format(info.total / 1073741824) }} Go
                    {% elif info.total >= 1048576 %}
                      {{ "%.1f"|format(info.total / 1048576) }} Mo
                    {% else %}
                      {{ "%.1f"|format(info.total / 1024) }} Ko
                    {% endif %}
                  </td>
                  <td>
                    {% set pct = info.pct|float %}
                    {% if pct > crit %}
                      <span class="badge bg-danger text-white">{{ pct }}%</span>
                    {% elif pct > warn %}
                      <span class="badge bg-warning text-dark">{{ pct }}%</span>
                    {% else %}
                      <span class="badge bg-success text-white">{{ pct }}%</span>
                    {% endif %}
                  </td>
                </tr>
              {% endfor %}
            </tbody>
          </table>
        {% endif %}

        {% if category == "storage" %}
          <table class="table table-sm">
            <thead><tr><th>Nom</th><th>Utilis√©</th><th>Total</th><th>%</th></tr></thead>
            <tbody>
              {% set warn = thresholds['storage']['warning'] %}
              {% set crit = thresholds['storage']['critical'] %}
              {% for name, info in values.items() %}
                {% if ".pct" not in name %}
                  <tr>
                    <td>{{ name }}</td>
                    <td>
                      {% if info.used >= 1073741824 %}
                        {{ "%.1f"|format(info.used / 1073741824) }} Go
                      {% elif info.used >= 1048576 %}
                        {{ "%.1f"|format(info.used / 1048576) }} Mo
                      {% else %}
                        {{ "%.1f"|format(info.used / 1024) }} Ko
                      {% endif %}
                    </td>
                    <td>
                      {% if info.total >= 1073741824 %}
                        {{ "%.1f"|format(info.total / 1073741824) }} Go
                      {% elif info.total >= 1048576 %}
                        {{ "%.1f"|format(info.total / 1048576) }} Mo
                      {% else %}
                        {{ "%.1f"|format(info.total / 1024) }} Ko
                      {% endif %}
                    </td>
                    <td>
                      {% set pct = info.pct|float %}
                      {% if pct > crit %}
                        <span class="badge bg-danger text-white">{{ pct }}%</span>
                      {% elif pct > warn %}
                        <span class="badge bg-warning text-dark">{{ pct }}%</span>
                      {% else %}
                        <span class="badge bg-success text-white">{{ pct }}%</span>
                      {% endif %}
                    </td>
                  </tr>
                {% endif %}
              {% endfor %}
            </tbody>
          </table>
        {% endif %}


      {% if category == "interfaces" %}
        <table class="table table-sm">
          <thead>
            <tr>
              <th>Interface</th><th>√âtat</th><th>Entrant</th><th>Sortant</th>
            </tr>
          </thead>
          <tbody>
            {% for iface, info in values.items() %}
              <tr>
                <td>{{ iface }}</td>
                <td>
                  {% if info.state == "up" %}
                    <span class="badge bg-success">Up</span>
                  {% elif info.state == "down" %}
                    <span class="badge bg-danger">Down</span>
                  {% else %}
                    <span class="badge bg-secondary">Unknown</span>
                  {% endif %}
                </td>

                <!-- Conversion lisible -->
                <td>
                  {% set in_val = info.in|float %}
                  {% if in_val >= 1073741824 %}
                    {{ "%.2f"|format(in_val / 1073741824) }} Go
                  {% elif in_val >= 1048576 %}
                    {{ "%.2f"|format(in_val / 1048576) }} Mo
                  {% elif in_val >= 1024 %}
                    {{ "%.2f"|format(in_val / 1024) }} Ko
                  {% else %}
                    {{ "%.0f"|format(in_val) }} o
                  {% endif %}
                </td>

                <td>
                  {% set out_val = info.out|float %}
                  {% if out_val >= 1073741824 %}
                    {{ "%.2f"|format(out_val / 1073741824) }} Go
                  {% elif out_val >= 1048576 %}
                    {{ "%.2f"|format(out_val / 1048576) }} Mo
                  {% elif out_val >= 1024 %}
                    {{ "%.2f"|format(out_val / 1024) }} Ko
                  {% else %}
                    {{ "%.0f"|format(out_val) }} o
                  {% endif %}
                </td>
              </tr>
            {% endfor %}
          </tbody>
        </table>

        <canvas id="chart-traffic" height="100"></canvas>
      {% endif %}



        {% if category in ["cpu", "ram", "storage"] %}
          <canvas id="chart-{{ category }}" height="100"></canvas>
        {% endif %}
      </div>
    </div>
  {% endfor %}
{% else %}
  <div class="alert alert-warning">Aucune m√©trique disponible pour cet h√¥te.</div>
{% endif %}

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
<script>
document.addEventListener("DOMContentLoaded", function () {
  const categories = ["cpu", "ram", "storage"];
  const hostId = parseInt(document.body.dataset.hostId);
  const timeSelect = document.getElementById("time-range");
  const charts = {}; // üîπ Stocke les instances Chart.js

  // Persist selected time-range per host so auto-refresh doesn't reset it
  try {
    const timeKey = `host_time_range_${hostId}`;
    if (timeSelect) {
      const stored = localStorage.getItem(timeKey);
      if (stored) timeSelect.value = stored;
      timeSelect.addEventListener('change', () => {
        try { localStorage.setItem(timeKey, timeSelect.value); } catch (e) {}
      });
    }
  } catch (e) { /* ignore storage errors */ }

  // üîπ Convertit "10m" / "1h" / "24h" / "7d" en minutes
  function getMinutes() {
    const val = timeSelect.value;
    if (val.endsWith("m")) return parseInt(val);
    if (val.endsWith("h")) return parseInt(val) * 60;
    if (val.endsWith("d")) return parseInt(val) * 24 * 60;
    return 10;
  }

  // üîπ Retourne l'unit√© de temps Chart.js et les displayFormats en fonction du nombre de minutes
  function timeUnitForMinutes(minutes) {
    if (minutes >= 24 * 60) {
      return { unit: 'day', displayFormats: { day: 'MMM d' } };
    }
    if (minutes >= 60) {
      return { unit: 'hour', displayFormats: { hour: 'HH:mm' } };
    }
    return { unit: 'minute', displayFormats: { minute: 'HH:mm' } };
  }

  // üîπ D√©tecte les gros 'gaps' temporels et ins√®re des points null pour couper la courbe.
  // Retourne la liste d'intervalles [{start: ISO, end: ISO}] repr√©sentant les p√©riodes manquantes.
  function detectAndInsertGaps(datasets) {
    const allTs = [];
    datasets.forEach(ds => ds.data.forEach(p => {
      try { allTs.push(new Date(p.x).getTime()); } catch (e) {}
    }));
    allTs.sort((a,b) => a - b);
    if (allTs.length < 2) return [];

    const deltas = [];
    for (let i = 1; i < allTs.length; i++) deltas.push(allTs[i] - allTs[i-1]);
    deltas.sort((a,b)=>a-b);
    const medianDelta = deltas[Math.floor(deltas.length/2)] || deltas[0] || 60000;
    const threshold = Math.max(medianDelta * 3, 2 * 60 * 1000); // au moins 2 minutes

    const intervals = [];
    for (let i = 1; i < allTs.length; i++) {
      const gap = allTs[i] - allTs[i-1];
      if (gap > threshold) {
        const start = new Date(allTs[i-1]).toISOString();
        const end = new Date(allTs[i]).toISOString();
        intervals.push({ start, end });

        // insert a null point at midpoint to force Chart.js to break the line
        const midMs = Math.floor((allTs[i-1] + allTs[i]) / 2);
        const midISO = new Date(midMs).toISOString();
        datasets.forEach(ds => {
          ds.data.push({ x: midISO, y: null });
          ds.data.sort((a,b) => new Date(a.x) - new Date(b.x));
        });
      }
    }
    return intervals;
  }

  // üîπ Plugin Chart.js pour dessiner une zone rouge lors des p√©riodes down d√©tect√©es
  const downZonePlugin = {
    id: 'downZone',
    beforeDraw(chart) {
      const cfg = chart.options.plugins && chart.options.plugins.downZone;
      if (!cfg || !cfg.intervals || !cfg.intervals.length) return;
      const xScale = chart.scales.x;
      if (!xScale) return;
      const ctx = chart.ctx;
      const top = chart.chartArea.top;
      const bottom = chart.chartArea.bottom;
      ctx.save();
      ctx.fillStyle = 'rgba(220,53,69,0.12)';
      cfg.intervals.forEach(iv => {
        try {
          const x1 = xScale.getPixelForValue(iv.start);
          const x2 = xScale.getPixelForValue(iv.end);
          const left = Math.min(x1, x2);
          const w = Math.abs(x2 - x1);
          ctx.fillRect(left, top, w, bottom - top);
        } catch (e) {}
      });
      ctx.restore();
    }
  };
  // register plugin once
  try {
    if (typeof Chart !== 'undefined') Chart.register(downZonePlugin);
  } catch (e) {
    console.warn('downZone plugin registration failed', e);
  }

  // üîπ Fonction d‚Äôaffichage / mise √† jour d‚Äôune cat√©gorie
  function loadCategory(category, minutes) {
    fetch(`/api/poll/metrics/${hostId}/${category}?minutes=${minutes}`)
      .then(resp => resp.json())
      .then(data => {
        if (!data || data.length === 0) {
          console.warn(`[chart] Pas de donn√©es pour ${category}`);
          return;
        }

        const byMetric = {};
        const metricMap = {};
        let coreIndex = 1;

        data.forEach(entry => {
          let label = entry.metric;
          if (category === "cpu") {
            if (!metricMap[label]) metricMap[label] = `Core ${coreIndex++}`;
            label = metricMap[label];
          }
          if (!byMetric[label]) byMetric[label] = [];
          byMetric[label].push({ x: entry.timestamp, y: entry.value });
        });

        if (category === "ram") {
          const filtered = {};
          if (byMetric["pct"]) filtered["Physical memory"] = byMetric["pct"];
          Object.keys(byMetric).forEach(k => delete byMetric[k]);
          Object.assign(byMetric, filtered);
        }

        if (category === "storage") {
          const filtered = {};
          data.forEach(entry => {
            let label = entry.metric;
            if (!label.endsWith(".pct")) return;
            const lname = label.toLowerCase();
            const ignored = ["shm", "tmp", "run", "dev", "proc", "sys"];
            if (ignored.some(sub => lname.includes(sub))) return;
            label = label.replace(/\.pct$/, "");
            if (!filtered[label]) filtered[label] = [];
            filtered[label].push({ x: entry.timestamp, y: entry.value });
          });
          Object.keys(byMetric).forEach(k => delete byMetric[k]);
          Object.assign(byMetric, filtered);
        }

        let datasets = Object.entries(byMetric).map(([metric, points]) => ({
          label: metric,
          data: points.map(p => ({ x: p.x, y: p.y })),
          fill: false,
          tension: 0.2,
          pointRadius: 0,       
          pointHoverRadius: 4    
        }));

  // detect gaps and insert nulls to break lines; also get intervals for shading
  const gapIntervals = detectAndInsertGaps(datasets);

  // Force the x-axis window to the requested period so the chart always shows
  // the full selected timeframe (even if data covers only part of it).
  const endTs = new Date();
  const startTs = new Date(endTs.getTime() - minutes * 60 * 1000);
  const tu = timeUnitForMinutes(minutes);

        const yAxisOptions = {
          beginAtZero: true,
          max: 100,
          title: { display: true, text: (category === 'cpu') ? 'Charge CPU (%)' : 'Utilisation (%)' }
        };

        const ctx = document.getElementById(`chart-${category}`);
        if (!ctx) return;

        // üîπ Si le graphe existe d√©j√† ‚Üí on met √† jour
        if (charts[category]) {
          charts[category].data.datasets = datasets;
          charts[category].options.plugins.title.text = `Historique ${category.toUpperCase()} (${minutes} min)`;
          // update downZone intervals
          if (!charts[category].options.plugins.downZone) charts[category].options.plugins.downZone = {};
          charts[category].options.plugins.downZone.intervals = gapIntervals;
          // enforce fixed time window and proper time unit/format
          if (!charts[category].options.scales) charts[category].options.scales = {};
          if (!charts[category].options.scales.x) charts[category].options.scales.x = {};
          charts[category].options.scales.x.min = startTs.toISOString();
          charts[category].options.scales.x.max = endTs.toISOString();
          charts[category].options.scales.x.time = { unit: tu.unit, displayFormats: tu.displayFormats };
          charts[category].update();
        } else {
          // üîπ Sinon on le cr√©e
          charts[category] = new Chart(ctx, {
            type: 'line',
            data: { datasets },
            options: {
              responsive: true,
              spanGaps: false,
              plugins: {
                title: { display: true, text: `Historique ${category.toUpperCase()} (${minutes} min)` },
                tooltip: {
                  callbacks: {
                    label: ctx => {
                      if (ctx.parsed && ctx.parsed.y === null) return `${ctx.dataset.label}: (no data)`;
                      return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}%`;
                    }
                  }
                },
                downZone: { intervals: gapIntervals }
              },
              scales: {
                x: { type: 'time', time: { unit: tu.unit, displayFormats: tu.displayFormats }, title: { display: true, text: 'Temps' }, min: startTs.toISOString(), max: endTs.toISOString() },
                y: yAxisOptions
              }
            }
          });
        }
      })
      .catch(err => console.error(`Erreur ${category} :`, err));
  }

  // üîπ Fonction pour les interfaces
  function loadInterfaces(minutes) {
    fetch(`/api/poll/metrics/${hostId}/interfaces?minutes=${minutes}`)
      .then(resp => resp.json())
      .then(data => {
        if (!data || data.length === 0) {
          console.warn("[chart] Pas de donn√©es interfaces");
          return;
        }

        const totalIn = {}, totalOut = {};
        data.forEach(entry => {
          const ts = entry.timestamp;
          if (entry.metric.endsWith(".in"))  totalIn[ts]  = (totalIn[ts]  || 0) + entry.value;
          if (entry.metric.endsWith(".out")) totalOut[ts] = (totalOut[ts] || 0) + entry.value;
        });

        function computeRates(map) {
          const entries = Object.entries(map).sort((a, b) => new Date(a[0]) - new Date(b[0]));
          const rates = [];
          for (let i = 1; i < entries.length; i++) {
            const tPrev = new Date(entries[i - 1][0]);
            const tCurr = new Date(entries[i][0]);
            const dt = (tCurr - tPrev) / 1000;
            if (dt <= 0) continue;
            let delta = entries[i][1] - entries[i - 1][1];
            if (delta < 0) delta = 0;
            const mbps = (delta * 8) / (dt * 1_000_000);
            rates.push({ x: entries[i][0], y: mbps });
          }
          return rates;
        }

        const inData  = computeRates(totalIn);
        const outData = computeRates(totalOut).map(p => ({ x: p.x, y: -p.y }));
        const ctx = document.getElementById("chart-traffic");
        if (!ctx) return;

        const datasets = [
          {
            label: "Inbound (Mbps)",
            data: inData,
            borderColor: "rgba(0, 200, 83, 0.9)",
            backgroundColor: "rgba(0, 200, 83, 0.1)",
            fill: true,
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 0,          
            pointHoverRadius: 4
          },
          {
            label: "Outbound (Mbps)",
            data: outData,
            borderColor: "rgba(244, 67, 54, 0.9)",
            backgroundColor: "rgba(244, 67, 54, 0.1)",
            fill: true,
            tension: 0.3,
            borderWidth: 2,
            pointRadius: 0,         
            pointHoverRadius: 4
          }
        ];

  // detect gaps and insert nulls for interfaces as well
  const gapIntervalsIf = detectAndInsertGaps(datasets);

  // enforce fixed time window for traffic chart
  const endTsIf = new Date();
  const startTsIf = new Date(endTsIf.getTime() - minutes * 60 * 1000);
  const tuIf = timeUnitForMinutes(minutes);

        if (charts["interfaces"]) {
          charts["interfaces"].data.datasets = datasets;
          charts["interfaces"].options.plugins.title.text = `Overall Network Traffic (Mbps, ${minutes} min)`;
          charts["interfaces"].options.plugins.downZone = { intervals: gapIntervalsIf };
          if (!charts["interfaces"].options.scales) charts["interfaces"].options.scales = {};
          if (!charts["interfaces"].options.scales.x) charts["interfaces"].options.scales.x = {};
          charts["interfaces"].options.scales.x.min = startTsIf.toISOString();
          charts["interfaces"].options.scales.x.max = endTsIf.toISOString();
          charts["interfaces"].options.scales.x.time = { unit: tuIf.unit, displayFormats: tuIf.displayFormats };
          charts["interfaces"].update();
        } else {
          charts["interfaces"] = new Chart(ctx, {
            type: "line",
            data: { datasets },
            options: {
              responsive: true,
              spanGaps: false,
              interaction: { mode: "index", intersect: false },
              stacked: false,
              plugins: {
                legend: { position: "top" },
                title: { display: true, text: `Overall Network Traffic (Mbps, ${minutes} min)` },
                tooltip: {
                  callbacks: {
                    label: (ctx) => {
                      if (ctx.parsed && ctx.parsed.y === null) return `${ctx.dataset.label}: (no data)`;
                      return `${ctx.dataset.label}: ${Math.abs(ctx.parsed.y).toFixed(3)} Mbps`;
                    }
                  }
                },
                downZone: { intervals: gapIntervalsIf }
              },
              scales: {
                x: {
                  type: "time",
                  time: { unit: tuIf.unit, displayFormats: tuIf.displayFormats },
                  title: { display: true, text: "Horodatage" },
                  min: startTsIf.toISOString(),
                  max: endTsIf.toISOString()
                },
                y: {
                  beginAtZero: true,
                  title: { display: true, text: "D√©bit (Mbps)" },
                  ticks: { callback: (v) => Math.abs(v) }
                }
              }
            }
          });
        }
      })
      .catch(err => console.error("Erreur network traffic:", err));
  }

  // üîπ Charge tous les graphes
  function loadCharts() {
    const minutes = getMinutes();
    categories.forEach(c => loadCategory(c, minutes));
    loadInterfaces(minutes);
  }

  // üîπ √âv√©nement de changement de p√©riode
  timeSelect.addEventListener("change", () => {
    loadCharts(); // ‚úÖ pas de suppression des canvas
  });

  // Premier chargement
  loadCharts();
});
</script>

<!-- üîÑ Rafra√Æchissement auto toutes les 20s -->
<script>
  setInterval(() => location.reload(), 20000);
</script>

</body>
{% endblock %}
